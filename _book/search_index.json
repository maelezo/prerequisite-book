[
["index.html", "Introduction to R Programming Lesson: 1 Basic Data Structures 1.1 The R Programming Language 1.2 Installation 1.3 R Environment and Workspace 1.4 Types and Shape of Data 1.5 Data Types 1.6 Data Structures 1.7 Input/Output Data 1.8 Getting Help 1.9 Practice Problem", " Introduction to R Programming DSCOE Team 2017-04-16 Lesson: 1 Basic Data Structures 1.1 The R Programming Language R is an extremely powerful statistical scripting language. It is open-source and used broadly across academia, research organizations, and businesses. It is often the tool of choice for data scientists, data analysts, quantitative financial analysts, and a myriad of other professions. It is used for research at the vast majority of graduate schools. It is currently used by companies like Facebook, Google, the NY Times and Wallstreet financial organizations. Microsoft has invested heavily in integrating R into its desktop and cloud data science tools. Google has written the R Style Guide that is widely used. Facebook data scientists use R to analyze and understand the vast Facebook social network. Figure 1: Facebook created this image with R to show how Facebook connects the world 1.1.1 R or Python? The world is quickly moving toward leveraging open source data science tools rather than proprietary software. Over the last 5 years R and Python have risen as the two primary open source tools used by data professionals. While there is significant overlap in the capabilities of both languages, in general the R Programming language is better at data analysis and visualization, and Python is better at data acquisition and producing code for production environments. We decided to teach R in this class since it generally has better visualizations, allowing our analysts to tell the data narrative. Additionally, R is generally more accessible across the Department of Defense. Figure 2: LAVASTORM 2014 Survey of Industry: Primary tools used by data scientists R is open-source and is freely available to download. You can use base R as-is to write and run R scripts. That being said, RStudio has provided a very useful Integrated Development Environment (IDE) or “front-end” for R that is generally easier to use (R is still the “engine”; you can’t run RStudio without R). We will primarily use RStudio in this course. Note that you can also run R from a server in the “cloud”. The Army Data Science Center of Education (DSCOE) provides several tutorials that explain how to do this. 1.2 Installation Install Base R by going to http://cran.r-project.org/bin/windows/base/ Install RStudio by going to http://www.rstudio.com/products/rstudio/download/ 1.3 R Environment and Workspace Introductory Video: R is always pointing to a specific directory (or folder) on your computer. This is called your working directory. R will always directly read files and write files to this directory. You can see your working directory by typing getwd() ## [1] &quot;/home/dmbeskow/Dropbox/prerequisite-book&quot; If you want to change where your working directory is, you can do this three ways. If you are using RStudio, you can go to Session -&gt; Set Working Directory. You can also use the Files tab to navigate to your desired working directory, and then click on More -&gt; Set as Working Directory. If you want to change your working directory using a command (especially if you’re using base R), then you can type setwd(&quot;C:/Users/beskow/Documents&quot;) ###Make sure you use Forward Slashes in Windows If you want to see the names of files in your working directory without opening Windows Explorer, you can use the command dir() ## [1] &quot;01-fundamentals.Rmd&quot; &quot;02-munging.Rmd&quot; ## [3] &quot;03-visualization.Rmd&quot; &quot;04-control.Rmd&quot; ## [5] &quot;05-dates.Rmd&quot; &quot;06-exam.Rmd&quot; ## [7] &quot;07-references.Rmd&quot; &quot;_book&quot; ## [9] &quot;book.bib&quot; &quot;bookdown-demo.Rmd&quot; ## [11] &quot;bookdown-demo.Rproj&quot; &quot;_bookdown.yml&quot; ## [13] &quot;_build.sh&quot; &quot;dataframe.PNG&quot; ## [15] &quot;dataWrangling.jpg&quot; &quot;_deploy.sh&quot; ## [17] &quot;DESCRIPTION&quot; &quot;dplyr.png&quot; ## [19] &quot;environment.PNG&quot; &quot;facebook.png&quot; ## [21] &quot;filterColumn.PNG&quot; &quot;filterRow.PNG&quot; ## [23] &quot;index.Rmd&quot; &quot;KoreanConflict.csv&quot; ## [25] &quot;LICENSE&quot; &quot;list.PNG&quot; ## [27] &quot;matrix.PNG&quot; &quot;_output.yml&quot; ## [29] &quot;packages.bib&quot; &quot;preamble.tex&quot; ## [31] &quot;prerequisite-book.Rproj&quot; &quot;rating2.csv&quot; ## [33] &quot;README.md&quot; &quot;screen1.png&quot; ## [35] &quot;style.css&quot; &quot;summer.csv&quot; ## [37] &quot;tidyr.png&quot; &quot;toc.css&quot; ## [39] &quot;vector.PNG&quot; &quot;whyR2.PNG&quot; ## [41] &quot;whyR.PNG&quot; Note that this gives the names of the files in your working directory, which saves you the time of opening up Windows Explorer to remind yourself what you named your data file. 1.4 Types and Shape of Data Before we get into data, I first want to show you that your command line can operate like a calculator 5 + 4 + 7 * 7 ## [1] 58 or pi * 7.2^2 ## [1] 162.8602 Note that in both of these examples, the answer is printed to the screen, but not stored in memory. In other words, I cannot access that answer without redoing the calculation. If I want to store it in memory, then I assign the answer to a name. We use the symbol &lt;- to mean “assign”. In other words, the result of the computation on the right of the symbol is assigned to the name on the left of the symbol. For example: x &lt;- 4*4 I have now assigned the result of my computation to the name x. If I want to see this value of x in the future, I can just type it in the console. x ## [1] 16 Note that in RStudio you can also see your variable in the Environment window. I can also use it in future computations: y&lt;-x/2 x is now stored in your Global Environment. Think of this as your “workbench” that contains all of the data and values that you are working on. In RStudio, you can usually see what is in your Global Environment in the top right part of the RStudio window. Figure 3: The “Environment” window shows the name and type of data held in memory If you’re using base R, you can list the variables that are in your Global Environment by typing ls() ## [1] &quot;x&quot; &quot;y&quot; When you close either RStudio or base R, it will ask you if you want to save your work space. It is essentially asking you if you want to save what is on your workbench. If you choose “yes”, then it will save an *.RData file of everything that is in your workspace in your working directory. If you restart R from this working directory, it will load all of these items into your workspace. Generally it is not a good idea to save your workspace as long as you have all of the code it would take to quickly recreate all of the items in your workspace. However, if you have some code that takes along time to run, then it is best to save these items in a workspace so that you don’t have to wait hours/days a second time to recreate them. For example, I created some R code to “clean” operational combat data. It took approximately 11 days to clean the data. In this case, I would want to save my results so I don’t have to wait 11 days again for this to run. In general, however, R takes seconds to run, and it is best to not save your workspace as long as you have clean and easy to run code. 1.5 Data Types Now that we have R and RStudio installed, let’s look at different classes of data. The basic building blocks are integer, numeric, character, date, boolean (logical) or factor classes of data. The first four should be self explanatory, and examples of all four are below: x&lt;-4 #integer x&lt;-4.56 #numeric x&lt;-TRUE #boolean x&lt;-&quot;Rangers Lead the Way!&quot; #character Use the class command to find out what type of data you have. Note that because we were using x for all three, that we were writing over the value of x. At the end of running these four lines of code, x would equal the last line of code: the character string “Rangers Lead the Way!” class(x) ## [1] &quot;character&quot; R does not automatically recognize date data. When you read date data into R, it is initially converted to character data. If you want R to recognize it as a date, you need to explicity change it (we will go over this in more detail later): x&lt;-&quot;2014-01-01&quot; x&lt;-as.Date(x) class(x) ## [1] &quot;Date&quot; There is also a type of data called factor data. This is categorical data (often a character string) that has a numeric value tied to it for certain types of models. Character data is often coerced to the factor class when you have nominal data (for example, a gender field that contained the strings “male” and “female”). If I change this into a factor, it will still be represented as “male” and “female”, but it will also be represented numerically (as a 1 and 2). You need to be very careful when using factors, since many of the functions in R can’t handle factor data. You can see the use of factor data below: y&lt;-c(&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;male&quot;,&quot;female&quot;) This is character data. If I tried to plot y right now, R would show an error, since you can’t print character data. Lets convert this to a factor now: y&lt;-as.factor(y) y ## [1] male male female male female ## Levels: female male Now watch when I try to plot this: plot(y) It plots a barchart because R recognizes this as a factor and has a numeric value associated with both of the “levels” in the factor 1.6 Data Structures The data that we showed above is trivial (and very small) data. To work with data, we’d prefer to have it organized into a usable data structure. In this section we will introduce you to the four primary data structures that we will use: Data Structure Definition Vector Data in one dimension Data Frame Two dimensional data (most commonly used data structure) List A one dimensional data structure that can contain any class of data (objects could be other data structures) Matrix Multi-dimensional data of the same class There are also different dimensions of data. So far we’ve been using scalars, in which our variable x is a single value. Data can have 1, 2, or many dimensions, however. 1.6.1 Vector Data Structure One dimensional data that is of the same class is often organized into a vector. All objects in a vector must be of the same class (or will be coerced to the same class). A picture of a vector is given below Figure 4: Understanding Vector Data in R An example of a vector in R is given below: x&lt;-c(1,6,3,9,8,2) ## &quot;c&quot; means combine the values into a vector If you need to create a vector of sequential integers, you can use a colon: x&lt;-c(1:10) x ## [1] 1 2 3 4 5 6 7 8 9 10 If you need to create a vector of the same number, you can use the repeat command: rep(1,10) # Repeat 1 ten times ## [1] 1 1 1 1 1 1 1 1 1 1 1.6.2 Data Frame Data Structure Anyone who has used Microsoft Excel is used to seeing data in the traditional two dimensional table. The data frame structures data in this way. A picture of a data frame is provided below: Figure 5: Understanding Data Frame Structure in R Each column of a data frame is a vector, and must have the same class of data. A data frame is a list of vectors where each each vector has the same length. A data frame is usually created when you read data from an external file (usually a CSV file), but you can create one manually, as seen below: ##Create a data frame apft &lt;- data.frame(Name = c(&quot;John&quot;,&quot;Laura&quot;,&quot;Jim&quot;), Gender = c(&quot;M&quot;,&quot;F&quot;,&quot;M&quot;), PU = c(70, 52, 49), SU = c(90, 85, 60), Run = c(&quot;14:28&quot;,&quot;13:30&quot;,&quot;12:36&quot;)) ##Print object apft ## Name Gender PU SU Run ## 1 John M 70 90 14:28 ## 2 Laura F 52 85 13:30 ## 3 Jim M 49 60 12:36 1.6.3 List Data Structure A list is a linear container for objects of any class or data structure. Each object in list is separate and distinct. A list is helpful in several situations. For example, there are many time you have vectors that do not all have the same length. For example, lets say we extracted hash-tags from Tweets at the Rio Olympics. The number of hash-tags per tweet can range from zero to seven or eight (see Figure 6 below). You can’t store these vectors in a data frame because they aren’t the same length. A list is the appropriate object to store these vectors in. Figure 6: Understanding List Data Structure in R A list is also helpful for storing different types of data in a single object. For example, we can store a scalar, a data frame, and a vector in a single list: ##Store a scalar, vector, and data frame in a list myList &lt;- list(y, x, apft) ##Print object myList ## [[1]] ## [1] male male female male female ## Levels: female male ## ## [[2]] ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## [[3]] ## Name Gender PU SU Run ## 1 John M 70 90 14:28 ## 2 Laura F 52 85 13:30 ## 3 Jim M 49 60 12:36 Lists also create a great container for reading multiple data files into R and combining them into a single data frame. We will teach this technique later. 1.6.4 Matrix Data Structure While an important data structure in R, we will not use the matrix structure often in this course. A matrix is a multi-dimensional array of numeric, boolean, or integer data (NOT character, date, or factor data). Figure 7: Understanding Matrix Data Structure in R Below is an example of creating a matrix object in R: ## Example of setting row and column names mdat &lt;- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE) ##Print object mdat ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 11 12 13 As mentioned above, we will not use matrices much in this course. 1.7 Input/Output Data Now that we have all of that done, let’s learn how to read and write data. To do this with some fun data, let’s read in some data on movie ratings. This data contains users that rated movies in 2015. Each record (or row) represents a single user rating a single movie. Movies can have more than one rating, and users can rate more than one movie. Make sure you download the data at https://s3.amazonaws.com/dscoe-data/rating2.csv and follow along with this tutorial. Note: if you’re using a cloud environment, you can download the data by running the following command: download.file(&quot;https://s3.amazonaws.com/dscoe-data/rating2.csv&quot;, destfile = &quot;rating2.csv&quot;) We use the command read.csv to read in data. We also make sure to assign this to an object name (in this case, the object name is rating) rating &lt;- read.csv(&quot;rating2.csv&quot;, as.is = TRUE) The as.is = TRUE parameter ensures that any character data is formatted into a character vector rather than a factor vector. As a personal preference, I always explicitly convert to the factor data type when necessary so that I don’t have any undesired consequences. Now that we’ve read the file in, we’ll explore this data object a little bit. Below is the top commands that I use to explore a data object. One of the most powerful commands to explore any object is the structure command str. This command gives the overall size of the object (in this case it has 283,886 rows and 7 columns), as well as the class of each column vector and the first few observations from each column vector. ##The structure command prints the structure of the data object str(rating) ## &#39;data.frame&#39;: 283886 obs. of 7 variables: ## $ userId : int 31 31 31 31 31 31 31 31 31 31 ... ## $ movieId : int 1 110 260 364 527 588 594 616 1196 1197 ... ## $ rating : num 3 5 5 3 0.5 3 2.5 4 5 3 ... ## $ timestamp: chr &quot;2015-02-23 23:18:07&quot; &quot;2015-02-23 23:17:53&quot; &quot;2015-02-23 23:17:13&quot; &quot;2015-02-25 06:13:27&quot; ... ## $ year : int 2015 2015 2015 2015 2015 2015 2015 2015 2015 2015 ... ## $ title : chr &quot;Toy Story (1995)&quot; &quot;Braveheart (1995)&quot; &quot;Star Wars: Episode IV - A New Hope (1977)&quot; &quot;Lion King, The (1994)&quot; ... ## $ genres : chr &quot;Adventure|Animation|Children|Comedy|Fantasy&quot; &quot;Action|Drama|War&quot; &quot;Action|Adventure|Sci-Fi&quot; &quot;Adventure|Animation|Children|Drama|Musical|IMAX&quot; ... Related to the str command is the summary command. This command is especially helpful if you have numeric data in the object and you want to view some of the basic statistics regarding this data. ##The summary command prints summary statistics about an object in memory summary(rating) ## userId movieId rating timestamp ## Min. : 31 Min. : 1 Min. :0.5 Length:283886 ## 1st Qu.: 34847 1st Qu.: 2712 1st Qu.:3.0 Class :character ## Median : 69852 Median : 8644 Median :3.5 Mode :character ## Mean : 69325 Mean : 39896 Mean :3.5 ## 3rd Qu.:104000 3rd Qu.: 79132 3rd Qu.:4.0 ## Max. :138414 Max. :131262 Max. :5.0 ## year title genres ## Min. :2015 Length:283886 Length:283886 ## 1st Qu.:2015 Class :character Class :character ## Median :2015 Mode :character Mode :character ## Mean :2015 ## 3rd Qu.:2015 ## Max. :2015 I usually also use the command head to print the first 5 rows. This gives titles of the variables (columns) as well as a feel for the data: ##The head command prints the first five rows of the data set head(rating) ## userId movieId rating timestamp year ## 1 31 1 3.0 2015-02-23 23:18:07 2015 ## 2 31 110 5.0 2015-02-23 23:17:53 2015 ## 3 31 260 5.0 2015-02-23 23:17:13 2015 ## 4 31 364 3.0 2015-02-25 06:13:27 2015 ## 5 31 527 0.5 2015-02-23 23:19:58 2015 ## 6 31 588 3.0 2015-02-25 05:41:09 2015 ## title ## 1 Toy Story (1995) ## 2 Braveheart (1995) ## 3 Star Wars: Episode IV - A New Hope (1977) ## 4 Lion King, The (1994) ## 5 Schindler&#39;s List (1993) ## 6 Aladdin (1992) ## genres ## 1 Adventure|Animation|Children|Comedy|Fantasy ## 2 Action|Drama|War ## 3 Action|Adventure|Sci-Fi ## 4 Adventure|Animation|Children|Drama|Musical|IMAX ## 5 Drama|War ## 6 Adventure|Animation|Children|Comedy|Musical If you only want to print the names of the columns, use the names command: ##The names command just prints the column names of a data frame names(rating) ## [1] &quot;userId&quot; &quot;movieId&quot; &quot;rating&quot; &quot;timestamp&quot; &quot;year&quot; &quot;title&quot; ## [7] &quot;genres&quot; Finally, if we only want the dimensions of the data, we can use dim to get all of the dimensions, *nrow to access the number of rows, and ncol to access the number of columns: ##The dim command prints the dimensions of the object dim(rating) ## [1] 283886 7 ##The nrow command prints the number of rows of a data frame nrow(rating) ## [1] 283886 ##The ncol command prints the number of columns of a data frame ncol(rating) ## [1] 7 1.8 Getting Help There’s several ways to get help in R. The help function and the ? function can access the documentation for packages and functions that you have loaded into R. help.search and the ?? function both search within documentation for loaded packages. Additionally, you can use the args function to print out the arguments for a function. ##Getting help for the str function help(str) ##or ?str ##Searching within documentation for &quot;subset&quot; help.search(&#39;subset&#39;) ##or ??subset 1.9 Practice Problem Download the Korean War Casualty Data by downloading the Comma Separated Value (CSV) file here: https://s3.amazonaws.com/dscoe-data/KoreanConflict.csv If you’re using a cloud environment, you can download the data by running the following command: download.file(&quot;https://s3.amazonaws.com/dscoe-data/KoreanConflict.csv&quot;, destfile = &quot;KoreanConflict.csv&quot;) Read this into your R environment. Explore the data given the commands that we leaned this lessons. We will use this data in future lessons. "],
["basic-data-manipulation.html", "Lesson: 2 Basic Data Manipulation 2.1 Data 2.2 Cell level data access 2.3 Table Command (and an example of data “cleaning”) 2.4 Filter (or subset) data 2.5 Using the grep and aggregate commands 2.6 Summary 2.7 Practice Problem", " Lesson: 2 Basic Data Manipulation The most time intensive task in data science endeavors is pre-processing data. Real world data is often complex and messy. Data processing (sometimes called “munging” or “data wrangling”) cleans and manipulates data so that it is in a form that is useful for models and visualizations. The R programming language is one of the best tools for manipulating data. This lesson will discuss the basics of data structure as well as ways to subset, extract and otherwise manipulate basic data. Figure 1: “Data Wrangling”&quot; is often the most difficult part of data science 2.1 Data For this lesson we will use casualty data from the Korean War. This data is available at Kaggle. You should have downloaded this data for the practice problem in Lesson 1. First, let’s read the data into R: kor &lt;- read.csv(&quot;KoreanConflict.csv&quot;, as.is = TRUE) Now let’s explore the data with some of the tools we learned in Lesson 1. First, let’s look at the structure of the data: str(kor) ## Print the structure of the Korean Casualty Data ## &#39;data.frame&#39;: 36574 obs. of 25 variables: ## $ SERVICE_TYPE : chr &quot;V&quot; &quot;R&quot; &quot;R&quot; &quot;V&quot; ... ## $ SERVICE_CODE : chr &quot;L&quot; &quot;K&quot; &quot;K&quot; &quot;L&quot; ... ## $ ENROLLMENT : chr &quot;ACTIVE - GUARD/RESERVE&quot; &quot;ACTIVE - REGULAR&quot; &quot;ACTIVE - REGULAR&quot; &quot;ACTIVE - GUARD/RESERVE&quot; ... ## $ BRANCH : chr &quot;AIR FORCE&quot; &quot;ARMY&quot; &quot;ARMY&quot; &quot;ARMY&quot; ... ## $ RANK : chr &quot;CAPT&quot; &quot;PVT&quot; &quot;PFC&quot; &quot;2LT&quot; ... ## $ PAY_GRADE : chr &quot;O03&quot; &quot;E02&quot; &quot;E03&quot; &quot;O01&quot; ... ## $ POSITION : chr &quot;&quot; &quot;FOOD SERVICE APPRENTICE&quot; &quot;HEAVY WEAPONS INFANTRYMAN&quot; &quot;INFANTRY UNIT COMMANDER&quot; ... ## $ BIRTH_YEAR : chr &quot;1917&quot; &quot;1927&quot; &quot;1932&quot; &quot;1929&quot; ... ## $ SEX : chr &quot;M&quot; &quot;M&quot; &quot;M&quot; &quot;M&quot; ... ## $ HOME_CITY : chr &quot;NEW YORK&quot; &quot;UNKNOWN&quot; &quot;UNKNOWN&quot; &quot;UNKNOWN&quot; ... ## $ HOME_COUNTY : chr &quot;NEW YORK&quot; &quot;OCONEE&quot; &quot;BIBB&quot; &quot;COAHOMA&quot; ... ## $ NATIONALITY : chr &quot;US&quot; &quot;US&quot; &quot;US&quot; &quot;US&quot; ... ## $ STATE_CODE : chr &quot;NY&quot; &quot;GA&quot; &quot;GA&quot; &quot;MS&quot; ... ## $ HOME_STATE : chr &quot;NEW YORK&quot; &quot;GEORGIA&quot; &quot;GEORGIA&quot; &quot;MISSISSIPPI&quot; ... ## $ MARITAL_STATUS : chr &quot;MARRIED&quot; &quot;UNKNOWN&quot; &quot;UNKNOWN&quot; &quot;UNKNOWN&quot; ... ## $ ETHNICITY : chr &quot;WHITE&quot; &quot;WHITE&quot; &quot;WHITE&quot; &quot;WHITE&quot; ... ## $ ETHNICITY_1 : chr &quot;NOT SPECIFIED&quot; &quot;NOT SPECIFIED&quot; &quot;NOT SPECIFIED&quot; &quot;NOT SPECIFIED&quot; ... ## $ ETHNICITY_2 : chr &quot;WHITE&quot; &quot;WHITE&quot; &quot;WHITE&quot; &quot;WHITE&quot; ... ## $ DIVISION : chr &quot;93 BOMB SQ 19 BOMB GP&quot; &quot;29 RGT CMBT TEAM&quot; &quot;5 RGT 1 CAV DIV&quot; &quot;32 INF 7 DIV&quot; ... ## $ INCIDENT_DATE : chr &quot;19510412&quot; &quot;19500727&quot; &quot;19510316&quot; &quot;19530122&quot; ... ## $ FATALITY_YEAR : chr &quot;1951&quot; &quot;1950&quot; &quot;1951&quot; &quot;1953&quot; ... ## $ FATALITY_DATE : chr &quot;20010402&quot; &quot;19500727&quot; &quot;19510316&quot; &quot;19530122&quot; ... ## $ HOSTILITY_CONDITIONS: chr &quot;H&quot; &quot;H&quot; &quot;H&quot; &quot;H&quot; ... ## $ FATALITY : chr &quot;DECLARED DEAD&quot; &quot;KILLED IN ACTION&quot; &quot;KILLED IN ACTION&quot; &quot;KILLED IN ACTION&quot; ... ## $ BURIAL_STATUS : chr &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; ... We see that this data has 36,574 rows and 25 columns. It appears that each row of the data represents an individual service member who died in the Korean War. Note that every single column is a character vector. This includes the rows like BIRTH_YEAR and INCIDENT_DATE that appear like they should be numeric (the fact that they are character means that at least one entry in this column has alphabetic letters rather than numbers). 2.2 Cell level data access This data set contains two dimensions (rows and columns). To access specific rows and columns in R, we use [row,column] format. For example, to access the data in the first row and first column of Korea data, we would use kor[1,1] ##First row, first column ## [1] &quot;V&quot; If we want to access the first 5 entries from the first column, we would use kor[1:5,1] ##First five entries from the first column ## [1] &quot;V&quot; &quot;R&quot; &quot;R&quot; &quot;V&quot; &quot;R&quot; Now if we want to access the first three rows from the 1st, 3rd, and 8th column, we use the following format kor[1:3,c(1,3,8)] ## SERVICE_TYPE ENROLLMENT BIRTH_YEAR ## 1 V ACTIVE - GUARD/RESERVE 1917 ## 2 R ACTIVE - REGULAR 1927 ## 3 R ACTIVE - REGULAR 1932 You can also use column names (or headers) to extract data from specific columns. This is especially helpful if you can’t remember respective column numbers, or if you think the column order will ever change. To extract the first three rows of data from BRANCH, RANK, and HOME_STATE, we can use the code below. kor[1:3,c(&quot;RANK&quot;,&quot;BRANCH&quot;,&quot;HOME_STATE&quot;)] ## RANK BRANCH HOME_STATE ## 1 CAPT AIR FORCE NEW YORK ## 2 PVT ARMY GEORGIA ## 3 PFC ARMY GEORGIA Remember that each column represents a vector. In addition to the method we just showed, you can access data from each column vector with the following script: kor$RANK[1:5] ##Prints first five entries in RANK vector ## [1] &quot;CAPT&quot; &quot;PVT&quot; &quot;PFC&quot; &quot;2LT&quot; &quot;CPL&quot; The script above essentially says select the RANK column from the kor data frame, and then print to the screen the first five entries of this column. 2.3 Table Command (and an example of data “cleaning”) Let’s explore the data a bit more. The table command provides a great way to see all of the possible entries in categorical data. The table command has similar functionality to Pivot Tables in Excel, but is much easier to use. To illustrate this command, we will table the BIRTH_YEAR table(kor$BIRTH_YEAR) ##Table BIRTH_YEAR ## ## 1889 1894 1895 1896 1900 1902 1903 1904 1905 1906 1907 1908 1909 1910 ## 2271 1 1 1 1 5 7 2 15 14 25 22 26 48 61 ## 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 ## 76 104 116 143 183 224 300 424 421 506 624 657 781 888 1107 ## 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 A2 A3 A4 ANT ART ## 1278 1988 3621 4358 5479 5077 3630 1296 328 61 8 16 3 1 31 ## AUT CHI CLA COA COM CON COR CRY ENG FIE FIR FIX FUE GEN GUN ## 13 41 1 1 8 2 4 1 1 6 2 3 1 71 1 ## HEA HIG INT LAN LAU LIG LOW MAJ MAR MIL MIN MOT NON OPE RAD ## 37 4 17 2 1 2 25 1 1 1 20 3 5 6 1 ## RAI SAX SIG SNA STA TAC TE TOP TRA TUB WAR ## 2 2 2 2 2 1 2 4 31 1 14 The table command provides the number of records for each category. Here we learn that our data is a bit messy. Notice that although most of the entries are numerical, that there are numerous entries that don’t look like a year. We can see this again if we table data by gender: table(kor$SEX) ##Table by gender ## ## 19040000 19060000 ## 2 1 ## 19070000 19080000 ## 3 1 ## 19081017 19090000 ## 1 1 ## 19100000 19110000 ## 4 6 ## 19120000 19130000 ## 1 2 ## 19130816 19140000 ## 1 3 ## 19150000 19150810 ## 7 1 ## 19160000 19170000 ## 6 2 ## 19180000 19190000 ## 11 14 ## 19190222 19200000 ## 1 7 ## 19210000 19220000 ## 13 11 ## 19230000 19240000 ## 6 16 ## 19240905 19250000 ## 1 15 ## 19250511 19250909 ## 1 1 ## 19260000 19270000 ## 20 19 ## 19280000 19280527 ## 36 1 ## 19281122 19290000 ## 1 47 ## 19290821 19291105 ## 1 1 ## 19300000 19300526 ## 41 1 ## 19300624 19310000 ## 1 36 ## 19311003 19320000 ## 1 15 ## 19320525 F ## 1 2 ## M MANUAL ## 36169 4 ## S2) S3) ## 8 16 ## S4) TRACK VEHICLE (3D ECHELON) ## 3 1 ## WHEEL VEHICLE GASOLINE) WHEEL YEHICLE (3D ECHELON) ## 1 9 Note that this doesn’t give just male and female. For our purposes we’re going to try to remove this messy data. Note that in some cases you will want to fix messy data, not remove it. In removing the data, I am going to assume that the same rows of data that produce errors in the GENDER field are the same rows of data that will produce errors in the BIRTH_YEAR data. To remove this data, we will leverage the fact that we want to keep all of the data from BIRTH_YEAR that is numeric, and get rid of every row of data that contains alphabetical character data. In the following code we will coerce this column into numeric data. kor$BIRTH_YEAR &lt;- as.numeric(kor$BIRTH_YEAR) ## Warning: NAs introduced by coercion The as.numeric command coerces the data to the numeric class. Note that there is also an as.character and as.factor command that will coerce data to these respective data classes. This as.numeric command will create an NA value for every entry that is not numeric. It is now much easier to remove all rows that contain an NA in the BIRTH_YEAR column. The code below provides a way to subset the data by removing the rows that contain an NA value in the BIRTH_YEAR column. There are many ways to subset and cut data in R. Below we will use the bracket functionality that we discussed above. You can also use the subset command in the base R packages. Later in this tutorial we will use the filter command that comes in the dplyr package. kor &lt;- kor[!is.na(kor$BIRTH_YEAR),] ##Remove rows that contain an NA value in the BIRTH_YEAR column In the code above, the is.na function produces a Boolean vector with TRUE values if an NA value is found. The exclamation point means NOT, and changes every TRUE to a FALSE (meaning it now produces a TRUE value if there is NOT an NA in that cell). By feeding this into our bracket functionality, we subset the data by removing all rows that contain an NA in the BIRTH_YEAR column. Now lets check the dimensions of our data: dim(kor) ## [1] 33899 25 We now have 33,899 rows of data, meaning that we lost 2,675 rows of data. If we were conducting an in-depth study of the Korean War Casualties, we couldn’t just delete this data, but would rather have to painstakingly clean it. For our purposes, we are just going to delete it. Now let’s see if that cleaned up the GENDER field. To do that, let’s call on the table command again: table(kor$SEX) ## ## F M ## 2 33897 Notice that the data is now clean, and that in our cleaned data we only have two female casualties recorded. Let’s now use the table command to explore the data a bit more. Let’s create a table by rank: table(kor$RANK) ## ## 1LT 1STLT 2LT 2NDLT A1C A2C A3C AA AB AN BG CAPT ## 665 617 400 221 76 67 30 6 5 28 1 458 ## CDR COL CPL CPO CPT CW2 CWO2 CWO-2 DN ENS FA FN ## 8 24 6035 25 239 4 3 1 1 61 16 29 ## GEN HA HN LCDR LT LTC LTCOL LTJG MAJ MG MSG MSGT ## 1 2 52 12 55 24 37 79 165 1 471 68 ## PFC PO1 PO2 PO3 PV1 PVT SA SFC SGT SN SSG SSGT ## 12826 44 32 119 7 6633 27 1154 2594 59 1 301 ## TSGT WO1 ## 97 18 From this we learn that the PFC rank sustained the highest casualty numbers, and that the highest ranking casualty was a General (assuming this means 4-star General). Now let’s explore NATIONALITY. We assume that this is all US Nationality, but when we run this table command table(kor$NATIONALITY) ## ## CA DA EI RP UK US ## 6 1 1 1 1 33889 we find out that there are a few other nationalities represented in the data. It’s interesting when we table the MARITAL_STATUS field that table(kor$MARITAL_STATUS) ## ## ANNULLED DIVORCED MARRIED NEVER MARRIED UNKNOWN ## 2 18 1129 993 31756 ## WIDOWED ## 1 we find out that the marital status of most of the casualties was unknown (which makes you wonder about the Defense Department data collection during the Korean War). Now let’s move on to filtering (or extracting a subset) of our data. 2.4 Filter (or subset) data Extracting a subset of data is one of the most fundamental tasks of data manipulation. There a many different ways to filter data in R. In addition to using the bracket functionality discussed above, you could use the subset command provided in Base R. Today, one of the foremost R Programming Developers (Hadley Wickam) has developed a special packages called dplyr [(Wickham and Francois 2016) and tidyr (Wickham 2016) just for data wrangling. For the sake of simplicity, we will attempt to primarily use these packages for data wrangling in this course. Given a two dimensional data structure, we can think of several ways we might want to extract data. The first is to extract rows associated with a certain feature. For example, if we had some basic data from an Army Physical Fitness (APFT) test, we may want to extract rows based on GENDER, as seen below. Figure 2: Filtering Rows by Categorical Variable If we were going to conduct this same operation (extract all FEMALE records) on our kor data frame with the dplyr package, we would execute the following command: library(dplyr) kor_female &lt;- dplyr::filter(kor, SEX==&quot;F&quot;) This command should produce a new data frame in your environment that has has two rows and 25 columns. This new data frame only contains the two FEMALE casualties represented in the data. To explore this much smaller data set, we could now table the data frame based on state: table(kor_female$HOME_STATE) ## ## IOWA WEST VIRGINIA ## 1 1 and find out that one woman is from Iowa, and the other from West Virginia. If we table based on rank: table(kor_female$RANK) ## ## 1STLT ## 2 we find out that both women were junior officers. If you take a look at the data further, you will learn that both women were in the Air Force and died in a non-hostile accident in 1952 on the same day (presumably the same accident). Note that we can also filter rows based on a Boolean function. For example, if we wanted to only look at casualties that were over 30 years old in 1950, we could filter with the following dplyr command: kor_Over30 &lt;- filter(kor, BIRTH_YEAR &lt; 1920) ##Filter those older than 30 in 1950 When you run this command, you will find that our cleaned data produces 2220 records of casualties that were over 30 in the year 1950. If we wanted to only select those individuals that were in their 30’s in 1950, we would use the following dplyr command: kor_30s &lt;- filter(kor, BIRTH_YEAR &lt; 1920 &amp; BIRTH_YEAR &gt; 1910) Running this command we find that 1,991 of the casualties were in their 30’s in 1950. Now that we’ve filtered by row, let’s show how to filter by column. We’ve already demonstrated above how to do this with the bracket notation, now we will illustrate how to do this using the dplyr package. We often find that we’ve loaded data that has many columns that we’re not interested in. In these cases, it is often helpful to extract the columns that we’re interested in. This will also shrink the size of our data in memory, and make our code run faster. In the picture below, we illustrate this with some simple APFT data (in this case we’re extracting the demographic and raw score columns): Figure 3: Filtering Specific Columns (or fields) Let’s say we were studying the Korean Casualty data to understand the time factor of those who died of wounds, and were particularly interested in the time between INCIDENT_DATE and FATALITY_DATE. Below we’ll extract these two columns with the dplyr package: kor_dates &lt;- select(kor, one_of(c(&quot;INCIDENT_DATE&quot;,&quot;FATALITY_DATE&quot;))) #Select two columns Now if we look at the structure of this new data frame: str(kor_dates) ## &#39;data.frame&#39;: 33899 obs. of 2 variables: ## $ INCIDENT_DATE: chr &quot;19510412&quot; &quot;19500727&quot; &quot;19510316&quot; &quot;19530122&quot; ... ## $ FATALITY_DATE: chr &quot;20010402&quot; &quot;19500727&quot; &quot;19510316&quot; &quot;19530122&quot; ... We see that we only have two columns, but still have all 33,899 rows. The code below is beyond the extent of this lesson on filtering (it contains some code we’ll go over in Lesson 5) but is interesting to look at the difference between incident date and fatality date. In this code we will load the lubridate package (Grolemund, Spinu, and Wickham 2016) (another package written by Hadley Wickam) and use it to convert these two columns to date format and calculate the difference between them (i.e. the number of days between the incident that the death of the Service Member). library(lubridate) days &lt;- ymd(kor_dates$FATALITY_DATE) - ymd(kor_dates$INCIDENT_DATE) days[1:100] ## Time differences in days ## [1] 18253 0 0 0 0 0 0 0 0 0 17697 ## [12] 0 0 0 18342 31 0 0 0 1153 0 3 ## [23] 0 0 355 0 0 0 0 0 0 0 53 ## [34] 0 0 0 0 0 0 0 0 NA 0 0 ## [45] NA 469 0 0 NA 0 0 981 0 0 0 ## [56] 0 0 1131 1155 46 0 0 0 0 0 NA ## [67] 0 NA 0 1125 959 0 469 0 0 0 969 ## [78] 0 0 31 0 1130 0 0 0 17568 0 1155 ## [89] 120 0 177 0 154 0 0 7 0 0 NA ## [100] 0 Looking at the first few entries makes us wonder. The very first entry had 18,253 days between the incident and the fatality. In fact, if you look closer at the dates, you will see that this Service Member had an incident on 12 April 1951, but wasn’t considered a fatality until 2 April 2001. In fact, if we quickly plot a histogram of the difference in days (you’ll learn this command next lesson): #plot histogram of difference in days hist(as.numeric(days), main=&quot;Histogram of Difference in Days&quot;, xlab=&quot;Days&quot;) Here we see that there’s a number of casualties that seem to have a fatality day around the year 2000. If you look at the original data will see that the first Service Member in the data (an Air Force Captain) is listed with an incident year of 1951 and FATALITY_DATE in 2001. Notice that the FATALITY status is DECLARED DEAD. This officer, as part of a bombing group, must have had an MIA status for several decades until finally “declared dead” in 2001. The “declared dead” date became his fatality date, which means it would be difficult to evaluate the temporal aspect of wound care with this data. 2.5 Using the grep and aggregate commands The following video illustrates how to use the grep and aggregate commands. This video will use movie rating data that you downloaded in Lesson 1. download.file(&quot;https://s3.amazonaws.com/dscoe-data/rating2.csv&quot;, destfile = &quot;rating2.csv&quot;) 2.6 Summary What we have seen is that R produces a great platform to rapidly “wrangle” and explore data. 2.7 Practice Problem Use grep to determine how many casualties had *INFANTRY somewhere in their title (use the POSITION field). References "],
["basic-visualization.html", "Lesson: 3 Basic Visualization 3.1 Bar Plot 3.2 Pie Plot 3.3 Histogram Plot 3.4 Time Series Plot 3.5 Practice Problem", " Lesson: 3 Basic Visualization The R Programming language has some of the most powerful data visualization packages available. These packages are continually expanded upon, with new data visualizations packages being created on a regular basis. In addition to packages that create your basic statistical visualization (line plots, bar plots, pie plots, etc) there are packages that create geospatial visualizations, 3D visualizations, as well as interactive visualizations. Lets start by reading in the Korean Conflict data and perform the primary cleaning functions that we performed last lesson. kor &lt;- read.csv(&#39;KoreanConflict.csv&#39;, as.is=TRUE) kor$BIRTH_YEAR &lt;- as.numeric(kor$BIRTH_YEAR) kor &lt;- kor[!is.na(kor$BIRTH_YEAR),] Now that we have the data in memory, we will use some basic visualizations to explore the data. In this lesson, we will primarily use visualizations from the ggplot2 package (Wickham and Chang 2016). If you haven’t installed this package yet, run the command install.packages('ggplot2'). 3.1 Bar Plot We will start by producing a basic barplot of categorical variables. First we’ll look at the BRANCH field for the Korean Casualties. library(ggplot2) ggplot(kor, aes(BRANCH)) + geom_bar() At first this command isn’t very intuitive. The ggplot command is used with all visualizations. In this command it says that we will create a visualization of the kor data set, and particularly look at the BRANCH variable. The next command says to take this specific field and create a barplot (we could create other plots with this data as well.) If we wanted to improve the color scheme, we could add fill = BRANCH. ggplot(kor, aes(BRANCH, fill = BRANCH)) + geom_bar() Now, let’s add a title. Additionally, we will get rid of the legend, since it the labels are already on the axis. ggplot(kor, aes(BRANCH, fill = BRANCH)) + geom_bar() + ggtitle(&quot;Casualties by Service&quot;)+ theme(legend.position=&quot;none&quot;) What if we wanted to stacked barplot? Say we wanted to see how the distribution of ETHNICITY in the service BRANCHES. First, let’s take a look at our categories: table(kor$ETHNICITY_2) ## ## AMERICAN INDIAN/ALASKA NATIVE ## 103 ## ASIAN ## 229 ## BLACK OR AFRICAN AMERICAN ## 1146 ## BLACK OR AFRICAN AMERICAN ## 3022 ## HISPANIC ONE RACE ## 566 ## NATIVE HAWAIIAN OR OTHER PACIFIC ISLANDER ## 142 ## WHITE ## 28691 These are rather long names to display on a chart. We will start by creating shorter names. We can do this in the code below using the ``grep command that we learned in Lesson 2: kor$ETHNICITY_2[grep(&quot;HAWAIIAN&quot;,kor$ETHNICITY_2)] &lt;- &quot;HAWAIIAN&quot; Now all we have to do to change in our previous code is to change the fill = BRANCH to fill = ETHNICITY_2: ggplot(kor, aes(BRANCH, fill = ETHNICITY_2)) + geom_bar() + ggtitle(&quot;Casualties by Service&quot;) 3.2 Pie Plot Statisticians will generally tell you that you should never use a Pie Plot (usually a bar plot is recommended because it is easier for the human eye to distinguish differences in magnitude). That being said, there are still a few occasional times when a pie plot is necessary. For this plot, we are going to use a function from the BASE graphics package (this comes with R and you don’t have to load it). The pie plot is very easy to produce if we wrap the pie() command around the table command: pie(table(kor$BRANCH), main = &quot;Korean War Casualties by Service&quot;) 3.3 Histogram Plot Now we’ll take a look at several ways to create histograms in R. This is where R will quickly outshine Microsoft Excel and other spreadsheet programs. While Excel can create a barplot just like R, it is extremely time consuming to create a histogram in Excel, whereas R can create one in one line code. Let’s create a histogram of the age or each Korean Casualty. Notice that we don’t have a field that has age in it, but we do have the BIRTH_YEAR and FATALITY_YEAR. The calculation below will create a new field that is the AGE of the casualty at death (notice that we remove all records with a FATALITY_DATE after 1960 in order to remove those who were MIA and declared dead at a later time). # Filter our MIA kor2 &lt;- dplyr::filter(kor, FATALITY_DATE &lt; 1960) # Coerce to numeric kor2$FATALITY_YEAR &lt;- as.numeric(kor2$FATALITY_YEAR) kor2$BIRTH_YEAR &lt;- as.numeric(kor2$BIRTH_YEAR) # Create AGE field kor2$AGE &lt;- kor2$FATALITY_YEAR - kor2$BIRTH_YEAR Now that we’ve created the AGE field, we will use two different techniques to create a histogram. The Base R package has a histogram function that is easy to use and helpful for exploring data. hist(kor2$AGE, freq=TRUE, main = &quot;Historgram of Age&quot;, xlab = &quot;AGE&quot;) The ggplot2 package also has the ability to generate a histogram that is generally better for presentations. ggplot(kor2, aes(AGE)) + geom_histogram() + ggtitle(&#39;Korean Casualty Age Distribution&#39;) 3.4 Time Series Plot Time series plots (and line plots in general) are helpful in visually identifying trends and anomalies in data. We are going to change our data sets to look at the Olympic data. This data set is the data on all Olympic metals for the Summer Olympics from 1896 to 2012. This data set is available here: https://s3.amazonaws.com/dscoe-data/summer.csv You can download the file with the following command: download.file(&quot;https://s3.amazonaws.com/dscoe-data/summer.csv&quot;, destfile = &quot;summer.csv&quot;) Now that you’ve acquired the data, read it into R and take a look at its structure with the following two commands: oly &lt;- read.csv(&#39;summer.csv&#39;, as.is = TRUE) str(oly) ## &#39;data.frame&#39;: 31165 obs. of 9 variables: ## $ Year : int 1896 1896 1896 1896 1896 1896 1896 1896 1896 1896 ... ## $ City : chr &quot;Athens&quot; &quot;Athens&quot; &quot;Athens&quot; &quot;Athens&quot; ... ## $ Sport : chr &quot;Aquatics&quot; &quot;Aquatics&quot; &quot;Aquatics&quot; &quot;Aquatics&quot; ... ## $ Discipline: chr &quot;Swimming&quot; &quot;Swimming&quot; &quot;Swimming&quot; &quot;Swimming&quot; ... ## $ Athlete : chr &quot;HAJOS, Alfred&quot; &quot;HERSCHMANN, Otto&quot; &quot;DRIVAS, Dimitrios&quot; &quot;MALOKINIS, Ioannis&quot; ... ## $ Country : chr &quot;HUN&quot; &quot;AUT&quot; &quot;GRE&quot; &quot;GRE&quot; ... ## $ Gender : chr &quot;Men&quot; &quot;Men&quot; &quot;Men&quot; &quot;Men&quot; ... ## $ Event : chr &quot;100M Freestyle&quot; &quot;100M Freestyle&quot; &quot;100M Freestyle For Sailors&quot; &quot;100M Freestyle For Sailors&quot; ... ## $ Medal : chr &quot;Gold&quot; &quot;Silver&quot; &quot;Bronze&quot; &quot;Gold&quot; ... Let’s say that we want to explore the trend of increased numbers of women participating in the Summer Olympics over the past century. To do this we could start by aggregating the number of Olympic medals by Year and Gender: oly_sum &lt;- aggregate(Athlete ~ Year + Gender, data=oly, length) Let’s take a look at the first few lines of this new data set to make sure that it aggregated the data as we anticipated: head(oly_sum) ## Year Gender Athlete ## 1 1896 Men 151 ## 2 1900 Men 501 ## 3 1904 Men 458 ## 4 1908 Men 789 ## 5 1912 Men 855 ## 6 1920 Men 1255 Everything looks good. Now we have a data set that we can use to create a time series line plot. We create this plot below: ggplot(oly_sum, aes(Year, Athlete, group = Gender, color = Gender)) + geom_line() + ggtitle(&#39;Summer Olympic Metals by Gender&#39;) From this graph we see that there was significant growth in the participation of women in the Olympics starting in the 1970’s (we also see an interesting spike in the number of medals for men in the 1920’s that we could explore if desired). Now let’s select a few of the prominent countries in the Summer Olympics (we’ll look at the permanent members of the UN Security Council: United States, Great Britain, France, China, and Russia). To start this let’s first look at the table of countries listed in the data set. table(oly$Country) ## ## AFG AHO ALG ANZ ARG ARM AUS AUT AZE BAH BAR BDI BEL BER ## 4 2 1 15 29 259 11 1189 146 26 27 1 1 411 1 ## BLR BOH BOT BRA BRN BUL BWI CAN CHI CHN CIV CMR COL CRC CRO ## 113 7 1 431 1 333 5 649 33 807 1 23 19 4 114 ## CUB CYP CZE DEN DJI DOM ECU EGY ERI ESP EST ETH EUA EUN FIN ## 410 1 56 507 1 6 2 28 1 442 39 45 260 223 456 ## FRA FRG GAB GBR GDR GEO GER GHA GRE GRN GUA GUY HAI HKG HUN ## 1396 490 1 1720 825 25 1305 16 148 1 1 1 8 4 1079 ## INA IND IOP IRI IRL IRQ ISL ISR ISV ITA JAM JPN KAZ KEN KGZ ## 38 184 3 61 30 1 17 7 1 1296 127 788 49 93 3 ## KOR KSA KUW LAT LIB LTU LUX MAR MAS MDA MEX MGL MKD MNE MOZ ## 529 6 2 20 4 55 2 22 8 6 106 24 1 14 2 ## MRI NAM NED NGR NIG NOR NZL PAK PAN PAR PER PHI POL POR PRK ## 1 4 851 84 1 554 190 121 3 17 15 9 511 33 58 ## PUR QAT ROU RSA RU1 RUS SCG SEN SGP SIN SLO SRB SRI SUD SUI ## 8 4 640 106 17 768 14 1 4 4 26 31 2 1 380 ## SUR SVK SWE SYR TAN TCH TGA THA TJK TOG TPE TRI TTO TUN TUR ## 2 34 1044 3 2 329 1 25 3 1 44 20 10 10 86 ## UAE UGA UKR URS URU USA UZB VEN VIE YUG ZAM ZIM ZZX ## 1 7 173 2049 76 4585 20 12 2 435 2 23 48 Studying this data a bit, we see that the ISO-3 code for Russia changed from URS to RUS after the fall of the Soviet Union. For our analysis, we will change all USR data to RUS. oly$Country[oly$Country==&quot;URS&quot;] &lt;- &quot;RUS&quot; Now will will aggregate the data by Year and Country as well as filter out the counties we are interested in (notice how we create a vector of our five countries and then use the %in% function to filter out multiple countries): library(dplyr) oly_country &lt;- aggregate(Medal ~ Country + Year, data = oly, length) countries &lt;- c(&#39;USA&#39;,&#39;GBR&#39;,&#39;FRA&#39;,&#39;CHN&#39;,&#39;RUS&#39;) oly_country2 &lt;- filter(oly_country, Country %in% countries) Having completed this, we will now plot a time series plot by country for the last century. ggplot(oly_country2, aes(Year,Medal,group = Country, color = Country)) + geom_line() + ggtitle(&#39;Summer Olympic Metals by Country&#39;) This plot highlights a bit of the history of the summer Olympics. Note that Russia began competing in the 1950’s and China didn’t begin competing until the mid-1980’s. While the US has the longest sustained volume, Russia has the highest number in a single year (1980). While Great Britain had a surge at the turn of the century, it has decreased to ~50 medals in the 1920’s, and stayed near this mark for most the century (as has France). 3.5 Practice Problem Using the Olympic Data and Google, try to recreate the plot below with a horizontal barplot and bars ordered by volume of medals. References "],
["introduction-to-control-structures.html", "Lesson: 4 Introduction to Control Structures 4.1 If - else Statements 4.2 Loops 4.3 Practice Problem", " Lesson: 4 Introduction to Control Structures This lesson will cover the if-then statement as well as the for loop and while loop. These are two very common control structures for all computer programming languages, and are used extensively in the R Programming Language. 4.1 If - else Statements The if-then statement allows us to automate decision points and guide the computer through a data flow diagram. The basic syntax is given below: if(&lt;condition&gt;) { ## do something } else if{ ## do something else } else { ## do something completely different } The else clause is not always necessary, and many times we just need an if statement: if(&lt;condition&gt;) { ## do something } The if-else statement is most often used in loops and functions. We’ll illustrate the use of the if-then statement in loops below. 4.2 Loops Loops provide a way to systematically walk down a data structure (usually a vector, data frame, or list) and accomplish a task. The for loop and the while loop will be the primary loops for this class. The for loop is used when we know ahead of time a finite number of iterations that we need to execute (for example, we execute a task for every object in a vector/list or every row in a data frame). The for loop below iterates over the values 1, 2, 3, 4, and 5 and prints each of the values. for(i in 1:5){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 Notice that we can also use i to access a value in a vector, a row in a data frame, or an object in a list. letters &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;) for(i in 1:4){ print(letters[i]) } ## [1] &quot;a&quot; ## [1] &quot;b&quot; ## [1] &quot;c&quot; ## [1] &quot;d&quot; You also don’t have to start with 1, or use the letter i: for (year in 2010:2015){ print(paste(&quot;The year is&quot;, year)) } ## [1] &quot;The year is 2010&quot; ## [1] &quot;The year is 2011&quot; ## [1] &quot;The year is 2012&quot; ## [1] &quot;The year is 2013&quot; ## [1] &quot;The year is 2014&quot; ## [1] &quot;The year is 2015&quot; The next command is often used to skip an iteration if a certain condition is met. The code below illustrates how to use the next for(i in 1:5){ if(letters[i]==&quot;c&quot;){ next } print(letters[i]) } ## [1] &quot;a&quot; ## [1] &quot;b&quot; ## [1] &quot;d&quot; ## [1] &quot;e&quot; Loops can also be nested inside of each other. This is useful when working with multiple dimensions (like matrices) or subsets of subsets (for example, the outer for loop iterates over countries, the inner for loop iterates over each city in a given country. An example of a nested for loop is given below, creating a multiplication table: # nested for: multiplication table mymat = matrix(nrow=10, ncol=10) # create a 30 x 30 matrix (of 30 rows and 30 columns) for(i in 1:nrow(mymat)) { # for each row for(j in 1:ncol(mymat)){ # for each column mymat[i,j] = i*j # assign values based on position: product of two indexes } } mymat ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 1 2 3 4 5 6 7 8 9 10 ## [2,] 2 4 6 8 10 12 14 16 18 20 ## [3,] 3 6 9 12 15 18 21 24 27 30 ## [4,] 4 8 12 16 20 24 28 32 36 40 ## [5,] 5 10 15 20 25 30 35 40 45 50 ## [6,] 6 12 18 24 30 36 42 48 54 60 ## [7,] 7 14 21 28 35 42 49 56 63 70 ## [8,] 8 16 24 32 40 48 56 64 72 80 ## [9,] 9 18 27 36 45 54 63 72 81 90 ## [10,] 10 20 30 40 50 60 70 80 90 100 The while loop is used when we don’t know how many iterations we need to go through, but we know the condition that needs to be met before we are done. i &lt;- 5 while(i &lt;= 25) { print(i) i &lt;- i + 5 } ## [1] 5 ## [1] 10 ## [1] 15 ## [1] 20 ## [1] 25 To finish out this lesson, we’ll provide an example below of a some more sophisticated code. This function simulates a round of play in the board game RISK. In the board game RISK, and attacker begins an assault against a defender, and the win/loss is adjudicated as both players begin rolling dice and comparing values. The simulation below plays through this entire series, declares whether the attacker or the defender won, and declares the number of armies left on the board for each player. Instead of doing this once, this code plays through this 10,000 times, and in the process calculates the probability of the attacher winning. This type of process is known as Monte Carlo Simulation. While you may not fully understand all aspects of this code, note throughout this function how important loops and if-else statements are: risk &lt;- function(attacker, defender, n=10000) { results &lt;- rep(NA, n) for(j in 1:n){ while(attacker &gt; 1 &amp; defender &gt; 0) { atk.dice &lt;- min(attacker-1, 3) def.dice &lt;- min(defender, 2) atk.roll &lt;- ceiling(runif(atk.dice)*6) def.roll &lt;- ceiling(runif(def.dice)*6) atk.roll &lt;- atk.roll[order(atk.roll,decreasing=T)] def.roll &lt;- def.roll[order(def.roll,decreasing=T)] comparison &lt;- min(atk.dice, def.dice) for (i in 1:comparison) { if (atk.roll[i] &gt; def.roll[i]) defender &lt;- defender-1 if (atk.roll[i] &lt;= def.roll[i]) attacker &lt;- attacker-1 } } if (defender==0) results[j] &lt;- &quot;Attacker&quot; if (defender&gt;0) results[j] &lt;- &quot;Defender&quot; } print(paste(&quot;The Probability of the Attacker winning is: &quot;,length(results[results==&quot;Attacker&quot;])/n)) } Now will illustrate how this function is used: risk(attacker=12,defender=6) ## [1] &quot;The Probability of the Attacker winning is: 1&quot; 4.3 Practice Problem Use the instructions below to determine and visualize the average rating by movie genres Read the Movie Ratings Data into R Use the code below to build a vector called genres that contains all unique genre names contained in the data set. library(stringr) genres &lt;- unique(unlist(str_split(rating$genres,&quot;\\\\|&quot;))) Create a vector object that is the same length as genres to contain the mean ratings Iterate over your original data set in a for loop, use the grep command to extract the subset that is related to a specific genre, and calculate the mean rating for that genre Create a barplot visualization of average ratings by genre "],
["introduction-to-dates-in-r.html", "Lesson: 5 Introduction to Dates in R 5.1 Dates with Base R 5.2 Dates with the Lubridate Package 5.3 POSIXct and POSIXlt", " Lesson: 5 Introduction to Dates in R We often see dates and times in data. Often each record (or row) of data is connected to at least one date or time. Similar to Microsoft Excel, R has a special class or format that it uses to work with dates. 5.1 Dates with Base R We will start by showing a few of the date commands that are built into the Base R package (later on we will take a look at the lubridate package (Grolemund, Spinu, and Wickham 2016), which has some more user friendly functions.) First we will demonstrate a couple commands that will generate the current date for your system (either your physical computer or your cloud computer). Below is the system date: Sys.Date() ## [1] &quot;2017-04-16&quot; Next we will show the system time down to hours, minutes, and seconds with the Time Zone: Sys.time() ## [1] &quot;2017-04-16 09:28:00 EDT&quot; Note that that these are not character objects: class(Sys.Date()) ## [1] &quot;Date&quot; This is a special class called the Date class. When you read data into R, your fields that have dates are normally converted to the character class, not the date class. In order to convert from a character class to the date class in Base R, use the code below. # Create a character vector of random dates myDates &lt;- c(&quot;2016-02-07&quot;, &quot;2016-04-02&quot;,&quot;2016-06-28&quot;) #Convert character vector to dates vector myDates &lt;- as.Date(myDates) myDates ## [1] &quot;2016-02-07&quot; &quot;2016-04-02&quot; &quot;2016-06-28&quot; Now we’ll check to make sure we’ve converted it to the proper class of data: class(myDates) ## [1] &quot;Date&quot; Now that this is a date object, we can conduct mathematical operations that we could not conduct with a character vector, like subtracting 5 days from all dates: myDates - 5 ## [1] &quot;2016-02-02&quot; &quot;2016-03-28&quot; &quot;2016-06-23&quot; or checking the difference between dates: Sys.Date() - myDates[1] ## Time difference of 434 days The date formatting code above will only work as described if my input data are formatted exactly as shown, with four-digit years, two-digit months and days, and hyphens in between. In order to convert dates in a different format, you will use the format parameter and describe your unique date format as seen below: # Create a character vector of random dates myDates &lt;- c(&quot;02/07/2016&quot;, &quot;04/02/2016&quot;,&quot;06/28/2016&quot;) #Convert character vector to dates vector myDates &lt;- as.Date(myDates, format = &quot;%m/%d/%Y&quot;) myDates ## [1] &quot;2016-02-07&quot; &quot;2016-04-02&quot; &quot;2016-06-28&quot; Below is a table of all the most common date components and their abbreviation. Conversion Specification Definition %a Abbreviated weekday %A Full weekday %b Abbreviated month %B Full month %d Day of the month as decimal number (01–31). %H Hours as decimal number (00–23) %I Hours as decimal number (01–12) %m Month as decimal number (01–12) %M Minute as decimal number (00–59) %p AM/PM indicator in the locale. Used in conjunction with %I and not with %H %S Second as integer (00–61), allowing for up to two leap-seconds %w Weekday as decimal number (0–6, Sunday is 0). %y Year with two digits (87) %Y Year with century (1987) %Z Time zone abbreviation as a character string (empty if not available) 5.2 Dates with the Lubridate Package The lubridate package was developed to make date conversions faster and simpler. This package contains a few basic commands that will convert all of the most common date formats without the user having to specify their unique data format. The basic lubridate date conversions are ymd (year-month-day), mdy (month-day-year), and dmy (day-month-year). We’ve illustrated how to use these functions below: library(lubridate) ymd(&quot;2016-02-07&quot;, &quot;2016-04-02&quot;,&quot;2016-06-28&quot;) ## [1] &quot;2016-02-07&quot; &quot;2016-04-02&quot; &quot;2016-06-28&quot; Now we’ll use mdy to convert in a different format. mdy(&quot;02/07/2016&quot;, &quot;04/02/2016&quot;,&quot;06/28/2016&quot;) ## [1] &quot;2016-02-07&quot; &quot;2016-04-02&quot; &quot;2016-06-28&quot; To show the flexibility of this code, we’ll do a final example with dmy used on a different format data: dmy(&quot;1jan16&quot;, &quot;1nov15&quot;,&quot;15mar17&quot;) ## [1] &quot;2016-01-01&quot; &quot;2015-11-01&quot; &quot;2017-03-15&quot; The lubridate commands can be expanded to include hour-minute-seconds as well ymd_hms(&quot;2016-10-10 17:46:52&quot;, &quot;2016-11-14 12:04:05&quot;, &quot;2016-10-22 22:44:58&quot;) ## [1] &quot;2016-10-10 17:46:52 UTC&quot; &quot;2016-11-14 12:04:05 UTC&quot; ## [3] &quot;2016-10-22 22:44:58 UTC&quot; If you have times in different time zones, you can add a time zone parameter: ymd_hms(&quot;2016-10-10 17:46:52&quot;, tz=&quot;Pacific/Aukland&quot;) ## [1] &quot;2016-10-10 17:46:52 Pacific&quot; Note: UTC and GMT are Greenwich Mean Time (also known as “Zulu” time). 5.3 POSIXct and POSIXlt To fully understand how dates work in R, you will need study and understand the POSIXct and POSIXlt classes. You can learn more about these by typing ?POSIXct or ?POSIXlt respectively. References "],
["exam.html", "Lesson: 6 Exam", " Lesson: 6 Exam The final exam is a 20 question online test to evaluate your understanding of fundamental R principles. This exam is found at http:data-analytics.net/Apps/exam. You must attain a 70% on this exam (You will have five attempts to attain 70%). "],
["references.html", "References", " References "]
]
